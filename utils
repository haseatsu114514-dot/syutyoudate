// ============================================
// ユーティリティファイル - utils.gs
// ============================================

/**
 * LINE メッセージ送信（リトライ機能付き・デバッグ強化版）
 */
function sendLineMessage(userId, messages, token = null) {
  const startTime = Date.now();

  // デバッグ: 送信パラメータを詳細にログ出力
  console.log('=== sendLineMessage 開始 ===');
  console.log('宛先userId:', userId);
  console.log('使用トークン:', token ? 'カスタム(管理bot)' : 'デフォルト(メインbot)');
  console.log('メッセージ数:', messages ? messages.length : 0);

  // バリデーション
  if (!userId || !messages || !Array.isArray(messages) || messages.length === 0) {
    console.error('sendLineMessage: Invalid parameters');
    console.error('userId:', userId, 'messages:', JSON.stringify(messages));
    return false;
  }

  if (messages.length > 5) {
    console.error('メッセージ数が上限を超えています:', messages.length);
    return false;
  }

  // 各メッセージの妥当性チェック
  for (let i = 0; i < messages.length; i++) {
    const msg = messages[i];

    if (msg.type === 'text' && msg.text && msg.text.length > 5000) {
      console.error(`メッセージ${i + 1}が長すぎます:`, msg.text.length, '文字');
      return false;
    }

    if (msg.type === 'template' && msg.template && msg.template.type === 'buttons') {
      if (msg.template.text && msg.template.text.length > 160) {
        console.error(`Buttons template${i + 1}のテキストが長すぎます:`, msg.template.text.length, '文字');
        return false;
      }
    }

    if (msg.type === 'template' && msg.template && msg.template.type === 'confirm') {
      if (msg.template.text && msg.template.text.length > 240) {
        console.error(`Confirm template${i + 1}のテキストが長すぎます:`, msg.template.text.length, '文字');
        return false;
      }
    }
  }

  const url = 'https://api.line.me/v2/bot/message/push';

  const payload = {
    to: userId,
    messages: messages
  };

  const accessToken = token || CONFIG.LINE_CHANNEL_ACCESS_TOKEN;

  if (!accessToken) {
    console.error('アクセストークンが設定されていません');
    return false;
  }

  const options = {
    method: 'post',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${accessToken}`
    },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  // リトライ処理付き送信
  for (let attempt = 1; attempt <= CONFIG.RETRY_COUNT; attempt++) {
    try {
      console.log(`LINE送信試行 ${attempt}/${CONFIG.RETRY_COUNT}`);

      const response = UrlFetchApp.fetch(url, options);
      const responseCode = response.getResponseCode();

      if (responseCode === 200) {
        const duration = Date.now() - startTime;
        console.log(`✅ LINE送信成功 (${duration}ms):`, userId);
        console.log('送信先:', userId, '使用トークン:', token ? '管理bot' : 'メインbot');
        return true;
      } else if (responseCode === 429) {
        console.warn(`⚠️ レート制限エラー（試行${attempt}）`);
        if (attempt < CONFIG.RETRY_COUNT) {
          const backoffTime = CONFIG.RETRY_DELAY_MS * attempt;
          console.log(`待機中: ${backoffTime}ms`);
          Utilities.sleep(backoffTime);
          continue;
        }
      } else if (responseCode >= 500) {
        console.warn(`⚠️ サーバーエラー ${responseCode}（試行${attempt}）`);
        if (attempt < CONFIG.RETRY_COUNT) {
          Utilities.sleep(CONFIG.RETRY_DELAY_MS);
          continue;
        }
      } else {
        const responseText = response.getContentText();
        console.error('❌ LINE送信失敗:', responseCode, responseText);
        console.error('失敗詳細 - 宛先:', userId, '使用トークン:', token ? '管理bot' : 'メインbot');
        console.error('レスポンス内容:', responseText);
        logError('LINE送信失敗', `Code: ${responseCode}, User: ${userId}, Token: ${token ? '管理bot' : 'メインbot'}, Response: ${responseText}`);
        return false;
      }

    } catch (error) {
      console.error(`❌ LINE送信エラー（試行${attempt}）:`, error);

      if (attempt < CONFIG.RETRY_COUNT) {
        Utilities.sleep(CONFIG.RETRY_DELAY_MS);
        continue;
      } else {
        logError('LINE送信エラー', error.toString());
        return false;
      }
    }
  }

  const duration = Date.now() - startTime;
  console.error(`❌ LINE送信失敗 (${duration}ms): ${CONFIG.RETRY_COUNT}回の試行後に失敗`);
  logError('LINE送信失敗', `${CONFIG.RETRY_COUNT}回の試行後に失敗`);
  return false;
}

/**
 * 予約データ保存（容量チェック付き・最適化版）
 */
function saveBooking(requestId, bookingData) {
  const startTime = Date.now();

  try {
    const properties = PropertiesService.getScriptProperties();

    // データ容量チェック（10%の確率で実行）
    if (Math.random() < CONFIG.DATA_SIZE_CHECK_PROBABILITY) {
      checkDataSize();
    }

    const key = `booking_${requestId}`;
    const dataJson = JSON.stringify(bookingData);

    try {
      properties.setProperty(key, dataJson);
    } catch (saveError) {
      console.error('⚠️ 保存エラー - 古いデータを削除して再試行:', saveError);

      if (saveError.toString().includes('exceeded') ||
          saveError.toString().includes('limit') ||
          saveError.toString().includes('quota')) {
        cleanupOldLogs();

        try {
          properties.setProperty(key, dataJson);
        } catch (retryError) {
          console.error('❌ 再試行も失敗:', retryError);
          throw retryError;
        }
      } else {
        throw saveError;
      }
    }

    updateBookingIndex(requestId);

    const duration = Date.now() - startTime;
    console.log(`✅ 予約保存成功 (${duration}ms):`, requestId);

    return true;

  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`❌ saveBooking error (${duration}ms):`, error);
    logError('予約保存エラー', error.toString());

    try {
      const adminToken = CONFIG.ADMIN_BOT_TOKEN || null;
      sendLineMessage(CONFIG.ADMIN_USER_ID, [{
        type: 'text',
        text: `緊急: 予約保存エラー\n\n受付番号: ${requestId}\n\nエラー: ${error.toString()}`
      }], adminToken);
    } catch (notifyError) {
      console.error('管理者通知エラー:', notifyError);
    }

    return false;
  }
}

/**
 * 予約データ取得
 */
function getBooking(requestId) {
  try {
    const properties = PropertiesService.getScriptProperties();
    const key = `booking_${requestId}`;
    const data = properties.getProperty(key);

    return data ? JSON.parse(data) : null;

  } catch (error) {
    console.error('getBooking error:', error);
    logError('予約取得エラー', error.toString());
    return null;
  }
}

/**
 * ユーザーの予約一覧を取得
 */
function getUserBookings(userId) {
  const startTime = Date.now();

  try {
    const properties = PropertiesService.getScriptProperties();
    const indexData = properties.getProperty('booking_index');

    if (!indexData) {
      return [];
    }

    const requestIds = JSON.parse(indexData);
    const userBookings = [];

    requestIds.forEach(requestId => {
      const booking = getBooking(requestId);
      if (booking && booking.userId === userId) {
        userBookings.push(booking);
      }
    });

    userBookings.sort((a, b) => {
      return new Date(b.createdAt) - new Date(a.createdAt);
    });

    const duration = Date.now() - startTime;
    console.log(`getUserBookings (${duration}ms): ${userBookings.length}件取得`);

    return userBookings;

  } catch (error) {
    console.error('getUserBookings error:', error);
    logError('ユーザー予約取得エラー', error.toString());
    return [];
  }
}

/**
 * 予約インデックス更新
 */
function updateBookingIndex(requestId) {
  try {
    const properties = PropertiesService.getScriptProperties();
    const indexData = properties.getProperty('booking_index');

    let requestIds = indexData ? JSON.parse(indexData) : [];

    if (!requestIds.includes(requestId)) {
      requestIds.push(requestId);
      properties.setProperty('booking_index', JSON.stringify(requestIds));
    }

    return true;

  } catch (error) {
    console.error('updateBookingIndex error:', error);
    return false;
  }
}

/**
 * userIdで最新の承認済み予約を検索（高速化版）
 */
function findLatestApprovedBookingByUserId(userId) {
  const startTime = Date.now();

  try {
    const props = PropertiesService.getScriptProperties();
    
    // まずインデックスから予約IDリストを取得
    const indexData = props.getProperty('booking_index');
    if (!indexData) {
      console.log('予約インデックスが見つかりません');
      return null;
    }

    const requestIds = JSON.parse(indexData);
    let latestBooking = null;
    let latestTimestamp = 0;

    // インデックスの予約IDを新しい順（逆順）でチェック
    for (let i = requestIds.length - 1; i >= 0; i--) {
      const requestId = requestIds[i];
      const data = props.getProperty(`booking_${requestId}`);
      
      if (data) {
        try {
          const booking = JSON.parse(data);

          // userId一致 && 承認済み && 追加情報未入力
          if (booking.userId === userId &&
              booking.status === '承認済み' &&
              !booking.additionalInfo) {

            const timestamp = new Date(
              booking.approvedAt ||
              booking.updatedAt ||
              booking.createdAt
            ).getTime();

            if (timestamp > latestTimestamp) {
              latestTimestamp = timestamp;
              latestBooking = booking;
            }
          }
        } catch (parseError) {
          console.error('予約データのパースエラー:', requestId, parseError);
        }
      }
    }

    const duration = Date.now() - startTime;
    console.log(`findLatestApprovedBookingByUserId (${duration}ms): ${latestBooking ? '見つかった' : '見つからない'}`);

    return latestBooking;

  } catch (error) {
    console.error('findLatestApprovedBookingByUserId error:', error);
    return null;
  }
}

/**
 * Googleカレンダーに予約追加（複数カレンダー対応・最大2つ）
 */
function addToCalendar(dateTimeStr, course, requestId, name) {
  const startTime = Date.now();

  try {
    const calendarIds = CONFIG.CALENDAR_IDS.slice(0, 2);

    if (!calendarIds || calendarIds.length === 0) {
      console.error('カレンダーIDが設定されていません');
      return false;
    }

    const reservationTime = new Date(dateTimeStr);

    if (isNaN(reservationTime.getTime())) {
      console.error('日時のパースに失敗:', dateTimeStr);
      logError('カレンダーエラー', '日時パース失敗');
      return false;
    }

    const courseConfig = CONFIG.COURSES[course];
    if (!courseConfig) {
      console.error('無効なコースが指定されました:', course);
      logError('カレンダーエラー', '無効なコース');
      return false;
    }

    const duration = courseConfig.duration || 60;
    const bufferBefore = courseConfig.bufferBefore !== undefined ? courseConfig.bufferBefore : CONFIG.BUFFER_TIME;
    const bufferAfter = courseConfig.bufferAfter !== undefined ? courseConfig.bufferAfter : CONFIG.BUFFER_TIME;

    const bufferStartTime = new Date(reservationTime.getTime() - bufferBefore * 60 * 1000);
    const bufferEndTime = new Date(reservationTime.getTime() + (duration + bufferAfter) * 60 * 1000);
    const actualEndTime = new Date(reservationTime.getTime() + duration * 60 * 1000);

    const totalMinutes = bufferBefore + duration + bufferAfter;

    const formatTime = (date) => {
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      return `${hours}:${minutes}`;
    };

    const title = `【予約】${course} [${formatTime(bufferStartTime)}-${formatTime(bufferEndTime)}] 実施${formatTime(reservationTime)}-${formatTime(actualEndTime)}`;

    const description = `受付番号: ${requestId}\n\n` +
                        `【コース】${course}（施術${duration}分）\n\n` +
                        `【時間詳細】\n` +
                        `━━━━━━━━━━━━━━━━\n` +
                        `▼ 開始（バッファ含む）\n  ${formatTime(bufferStartTime)} [前バッファ${bufferBefore}分]\n\n` +
                        `▼ 施術開始\n  ${formatTime(reservationTime)}\n\n` +
                        `▼ 施術終了\n  ${formatTime(actualEndTime)}\n\n` +
                        `▼ 終了（バッファ含む）\n  ${formatTime(bufferEndTime)} [後バッファ${bufferAfter}分]\n` +
                        `━━━━━━━━━━━━━━━━\n\n` +
                        `【合計所要時間】\n${totalMinutes}分（施術${duration}分＋前バッファ${bufferBefore}分＋後バッファ${bufferAfter}分）`;

    let successCount = 0;
    let failedCalendars = [];

    for (let i = 0; i < calendarIds.length; i++) {
      const calendarId = calendarIds[i];

      try {
        console.log(`カレンダー${i + 1}/${calendarIds.length}に登録中: ${calendarId}`);

        const calendar = CalendarApp.getCalendarById(calendarId);

        if (!calendar) {
          console.warn(`カレンダーが見つかりません: ${calendarId}`);
          failedCalendars.push(calendarId);
          continue;
        }

        calendar.createEvent(
          title,
          bufferStartTime,
          bufferEndTime,
          {
            description: description
          }
        );

        successCount++;
        console.log(`✅ カレンダー${i + 1}登録成功: ${calendarId}`);

      } catch (calendarError) {
        console.error(`❌ カレンダー${i + 1}登録エラー:`, calendarError);
        failedCalendars.push(calendarId);
      }
    }

    const executionTime = Date.now() - startTime;

    if (successCount === 0) {
      console.error('全てのカレンダー登録に失敗しました');
      logError('カレンダーエラー', '全登録失敗');
      return false;
    }

    console.log(`✅ カレンダー登録完了 (${executionTime}ms): ${successCount}/${calendarIds.length}件成功`);
    if (failedCalendars.length > 0) {
      console.warn(`⚠️ 登録失敗: ${failedCalendars.join(', ')}`);
    }

    logAction('カレンダー登録', requestId, `${formatDateTime(bufferStartTime)} - ${formatDateTime(bufferEndTime)} (${successCount}/${calendarIds.length}件)`);

    return true;

  } catch (error) {
    const executionTime = Date.now() - startTime;
    console.error(`❌ addToCalendar error (${executionTime}ms):`, error);
    logError('カレンダー追加エラー', error.toString());
    return false;
  }
}

/**
 * アクションログ記録
 */
/**
 * アクションログ記録（軽量化版 - 最大50件）
 */
function logAction(action, userId, detail) {
  try {
    const properties = PropertiesService.getScriptProperties();
    // 既存ログを取得せず、上書きする運用も検討すべきだが、
    // ここでは件数を減らすことで対応
    const logsData = properties.getProperty('logs');

    let logs = [];
    if (logsData) {
      try {
        logs = JSON.parse(logsData);
      } catch (e) {
        logs = [];
      }
    }

    logs.push({
      timestamp: new Date().toISOString(),
      action: action,
      userId: userId,
      detail: detail
    });

    // 最新50件のみ保持（以前は1000件だったが重すぎるため削減）
    // ※本格的なログはスプレッドシートへの移行を推奨
    const MAX_LOGS_LITE = 50;
    if (logs.length > MAX_LOGS_LITE) {
      logs = logs.slice(-MAX_LOGS_LITE);
    }

    properties.setProperty('logs', JSON.stringify(logs));

  } catch (error) {
    console.error('logAction error:', error);
  }
}

/**
 * エラーログ記録
 */
/**
 * エラーログ記録（軽量化版 - 最大20件）
 */
function logError(action, detail) {
  try {
    const properties = PropertiesService.getScriptProperties();
    const errorsData = properties.getProperty('errors');

    let errors = [];
    if (errorsData) {
      try {
        errors = JSON.parse(errorsData);
      } catch (e) {
        errors = [];
      }
    }

    errors.push({
      timestamp: new Date().toISOString(),
      action: action,
      detail: detail
    });

    // 最新20件のみ保持（軽量化）
    const MAX_ERRORS_LITE = 20;
    if (errors.length > MAX_ERRORS_LITE) {
      errors = errors.slice(-MAX_ERRORS_LITE);
    }

    properties.setProperty('errors', JSON.stringify(errors));

  } catch (error) {
    console.error('logError error:', error);
  }
}

/**
 * データ容量監視（最適化版）
 */
function checkDataSize() {
  try {
    const properties = PropertiesService.getScriptProperties();
    const allData = properties.getProperties();

    let totalSize = 0;
    let bookingCount = 0;
    let logSize = 0;
    let errorLogSize = 0;

    for (const key in allData) {
      const itemSize = key.length + allData[key].length;
      totalSize += itemSize;

      if (key.startsWith('booking_')) {
        bookingCount++;
      } else if (key === 'logs') {
        logSize = itemSize;
      } else if (key === 'errors') {
        errorLogSize = itemSize;
      }
    }

    const totalKB = Math.round(totalSize / 1024);
    const usagePercent = Math.round((totalSize / 500000) * 100);

    console.log('=== データ容量レポート ===');
    console.log(`総容量: ${totalKB} KB (${usagePercent}%)`);
    console.log(`予約数: ${bookingCount}件`);
    console.log(`ログ容量: ${Math.round(logSize / 1024)} KB`);
    console.log(`エラーログ容量: ${Math.round(errorLogSize / 1024)} KB`);

    if (totalSize > CONFIG.DATA_SIZE_WARNING_THRESHOLD) {
      console.warn(`⚠️ データ容量が閾値を超えています: ${totalKB} KB`);

      const lastWarningDate = properties.getProperty('last_capacity_warning');
      const today = new Date().toDateString();

      if (lastWarningDate !== today) {
        const adminToken = CONFIG.ADMIN_BOT_TOKEN || null;
        sendLineMessage(CONFIG.ADMIN_USER_ID, [{
          type: 'text',
          text: `データ容量警告\n\n現在: ${totalKB} KB (${usagePercent}%)\n予約数: ${bookingCount}件\n\n古いデータの削除を推奨します`
        }], adminToken);

        properties.setProperty('last_capacity_warning', today);
      }
    }

    return totalSize;

  } catch (error) {
    console.error('checkDataSize error:', error);
    return 0;
  }
}

/**
 * 古いログのクリーンアップ（最適化版）
 */
function cleanupOldLogs() {
  const startTime = Date.now();

  try {
    console.log('=== 古いデータのクリーンアップ開始 ===');

    const properties = PropertiesService.getScriptProperties();
    let deletedCount = 0;

    // 1. ログを削減
    const logsData = properties.getProperty('logs');
    if (logsData) {
      const logs = JSON.parse(logsData);
      console.log(`現在のログ件数: ${logs.length}`);

      if (logs.length > 500) {
        const newLogs = logs.slice(-500);
        properties.setProperty('logs', JSON.stringify(newLogs));
        console.log(`✅ ログを削減: ${logs.length} → ${newLogs.length}`);
      }
    }

    // 2. エラーログを削減
    const errorsData = properties.getProperty('errors');
    if (errorsData) {
      const errors = JSON.parse(errorsData);
      console.log(`現在のエラーログ件数: ${errors.length}`);

      if (errors.length > 200) {
        const newErrors = errors.slice(-200);
        properties.setProperty('errors', JSON.stringify(newErrors));
        console.log(`✅ エラーログを削減: ${errors.length} → ${newErrors.length}`);
      }
    }

    // 3. 30日以前の完了した予約を削除
    const indexData = properties.getProperty('booking_index');
    if (indexData) {
      const requestIds = JSON.parse(indexData);
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

      const remainingIds = [];

      for (const requestId of requestIds) {
        const booking = getBooking(requestId);
        if (booking) {
          const bookingDate = new Date(booking.desiredDateTime);

          if (bookingDate < thirtyDaysAgo &&
              (booking.status === '承認済み' || booking.status === 'お断り' || booking.status === '確定')) {
            properties.deleteProperty(`booking_${requestId}`);
            deletedCount++;
          } else {
            remainingIds.push(requestId);
          }
        } else {
          remainingIds.push(requestId);
        }
      }

      if (deletedCount > 0) {
        properties.setProperty('booking_index', JSON.stringify(remainingIds));
        console.log(`✅ 古い予約を削除: ${deletedCount}件`);
      }
    }

    const duration = Date.now() - startTime;
    console.log(`=== クリーンアップ完了 (${duration}ms) ===`);

    return deletedCount;

  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`❌ cleanupOldLogs error (${duration}ms):`, error);
    logError('クリーンアップエラー', error.toString());
    return 0;
  }
}

/**
 * 自動メンテナンス（月次実行推奨）
 * トリガー設定: 時間主導型 > 月タイマー > 毎月1日 > 午前2-3時
 */
function autoMaintenance() {
  const startTime = Date.now();

  try {
    console.log('=== 自動メンテナンス開始 ===');
    console.log('実行日時:', new Date().toLocaleString('ja-JP'));

    // 1. データ容量チェック
    const totalSize = checkDataSize();
    const totalKB = Math.round(totalSize / 1024);
    const usagePercent = Math.round((totalSize / 500000) * 100);

    // 2. 古いデータをクリーンアップ
    const deletedCount = cleanupOldLogs();

    // 3. クリーンアップ後の容量チェック
    const newTotalSize = checkDataSize();
    const newTotalKB = Math.round(newTotalSize / 1024);
    const newUsagePercent = Math.round((newTotalSize / 500000) * 100);

    // 4. 管理者に通知
    const adminToken = CONFIG.ADMIN_BOT_TOKEN || null;
    
    let message = `【自動メンテナンス完了】\n\n`;
    message += `実行日時\n${new Date().toLocaleString('ja-JP')}\n\n`;
    message += `━━━━━━━━━━━━━━\n`;
    message += `削除した古い予約: ${deletedCount}件\n\n`;
    message += `データ容量\n`;
    message += `クリーンアップ前: ${totalKB} KB (${usagePercent}%)\n`;
    message += `クリーンアップ後: ${newTotalKB} KB (${newUsagePercent}%)\n`;
    message += `━━━━━━━━━━━━━━\n\n`;
    
    if (newUsagePercent >= 80) {
      message += `⚠️ 容量が80%を超えています\n手動でのデータ整理を推奨します`;
    } else if (newUsagePercent >= 60) {
      message += `注意: 容量が60%を超えています`;
    } else {
      message += `容量に問題ありません`;
    }

    /* 通知停止
    sendLineMessage(CONFIG.ADMIN_USER_ID, [{
      type: 'text',
      text: message
    }], adminToken);
    */

    const duration = Date.now() - startTime;
    console.log(`=== 自動メンテナンス完了 (${duration}ms) ===`);

    logAction('自動メンテナンス', 'system', `削除: ${deletedCount}件, 容量: ${newTotalKB}KB (${newUsagePercent}%)`);

  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`❌ autoMaintenance error (${duration}ms):`, error);
    logError('自動メンテナンスエラー', error.toString());

    // エラー通知
    try {
      const adminToken = CONFIG.ADMIN_BOT_TOKEN || null;
      sendLineMessage(CONFIG.ADMIN_USER_ID, [{
        type: 'text',
        text: `【自動メンテナンスエラー】\n\nエラーが発生しました\n\n${error.toString()}\n\n実行ログを確認してください`
      }], adminToken);
    } catch (notifyError) {
      console.error('エラー通知失敗:', notifyError);
    }
  }
}

// ============================================
// フォーム選択肢更新機能
// ============================================

/**
 * フォームの日付選択肢を空いている日のみに更新
 * ※ 日付ピッカーではなくドロップダウン型の場合のみ有効
 *
 * トリガー設定推奨:
 * - 毎朝6時に実行（時間主導型トリガー）
 * - 予約確定時にも呼び出し（approveReservation内）
 */
function updateFormDateChoices() {
  const startTime = Date.now();

  try {
    console.log('=== フォーム日付選択肢更新開始 ===');

    // フォームの編集用IDが必要（config.gsに設定が必要）
    const formEditId = CONFIG.FORM.BOOKING.EDIT_ID;
    if (!formEditId) {
      console.log('フォーム編集IDが設定されていません。スキップします。');
      return;
    }

    const form = FormApp.openById(formEditId);
    if (!form) {
      console.error('フォームが見つかりません');
      return;
    }

    // 「希望日」の質問を探す
    const items = form.getItems();
    let dateItem = null;

    for (const item of items) {
      if (item.getTitle() === '希望日') {
        // ドロップダウン型の場合のみ処理
        if (item.getType() === FormApp.ItemType.LIST) {
          dateItem = item.asListItem();
          break;
        } else if (item.getType() === FormApp.ItemType.MULTIPLE_CHOICE) {
          dateItem = item.asMultipleChoiceItem();
          break;
        } else {
          console.log('希望日は日付ピッカー型です。選択肢更新はスキップします。');
          return;
        }
      }
    }

    if (!dateItem) {
      console.log('希望日の質問が見つかりません');
      return;
    }

    // 空いている日を取得（14日間）
    const availableDates = getAvailableDates(14);

    if (availableDates.length === 0) {
      console.warn('空いている日がありません');
      return;
    }

    // 選択肢を更新
    const choices = availableDates.map(date => dateItem.createChoice(date));
    dateItem.setChoices(choices);

    const duration = Date.now() - startTime;
    console.log(`=== フォーム日付選択肢更新完了 (${duration}ms): ${availableDates.length}日 ===`);

    logAction('フォーム選択肢更新', 'system', `${availableDates.length}日`);

  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`updateFormDateChoices error (${duration}ms):`, error);
    logError('フォーム選択肢更新エラー', error.toString());
  }
}

/**
 * 空いている日を取得
 * @param {number} days - 何日先までチェックするか
 * @returns {string[]} - 空いている日の配列（例: ["2/1(土)", "2/3(月)"]）
 */
function getAvailableDates(days) {
  const availableDates = [];
  const dayNames = ['日', '月', '火', '水', '木', '金', '土'];

  try {
    const calendar = CalendarApp.getCalendarById(CONFIG.CALENDAR_IDS[0]);
    if (!calendar) {
      console.error('カレンダーが見つかりません');
      return [];
    }

    const now = new Date();
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // 最小コース時間を取得（デフォルト60分）
    let minDuration = 60;
    if (CONFIG.COURSES) {
      const durations = Object.values(CONFIG.COURSES).map(c => c.duration);
      if (durations.length > 0) {
        minDuration = Math.min(...durations);
      }
    }

    // 当日(i=0)から開始
    for (let i = 0; i <= days; i++) {
      const checkDate = new Date(today);
      checkDate.setDate(today.getDate() + i);

      // 当日の場合：5時間ルール + 施術時間を考慮して予約可能か判定
      if (i === 0) {
        // 営業終了時刻
        const endHour = CONFIG.BUSINESS_HOURS.END;
        // 最終予約開始可能時刻 = 営業終了 - 最小施術時間(時間換算)
        // ※ここではシンプルに「施術が終わる時間」が営業終了を超えないようにする
        const lastStartHour = endHour - (minDuration / 60); 
        
        // 予約締切時刻 = 最終開始時刻 - 5時間
        const deadlineHour = lastStartHour - CONFIG.BOOKING_DEADLINE_HOURS;

        // 現在時刻と比較 (厳密に分単位でチェック)
        const deadlineTime = new Date();
        deadlineTime.setHours(Math.floor(deadlineHour), (deadlineHour % 1) * 60, 0, 0);
          
        if (now >= deadlineTime) {
          // 当日はもう予約できない
          continue;
        }
      }

      // その日の営業時間内にイベントがあるかチェック
      const dayStart = new Date(checkDate);
      dayStart.setHours(CONFIG.BUSINESS_HOURS.START, 0, 0, 0);

      const dayEnd = new Date(checkDate);
      dayEnd.setHours(CONFIG.BUSINESS_HOURS.END, 0, 0, 0);

      const events = calendar.getEvents(dayStart, dayEnd);

      // 空き時間があるかチェック（簡易版: イベント数が少なければ空きあり）
      const businessHoursDuration = CONFIG.BUSINESS_HOURS.END - CONFIG.BUSINESS_HOURS.START;
      
      // イベントの合計時間を計算
      let totalEventDurationMinutes = 0;
      events.forEach(e => {
        totalEventDurationMinutes += (e.getEndTime() - e.getStartTime()) / (1000 * 60);
      });
      
      // 営業時間の何割が埋まっているかで判定（90%以上埋まっていたら除外）
      const totalBusinessMinutes = businessHoursDuration * 60;
      if (totalEventDurationMinutes < totalBusinessMinutes * 0.9) {
        const year = checkDate.getFullYear();
        const month = checkDate.getMonth() + 1;
        const date = checkDate.getDate();
        const dayName = dayNames[checkDate.getDay()];
        // 年を含めることで年またぎでも安定動作
        availableDates.push(`${year}/${month}/${date}(${dayName})`);
      }
    }

  } catch (error) {
    console.error('getAvailableDates error:', error);
  }

  return availableDates;
}

/**
 * 手動でフォーム選択肢を更新するためのテスト関数
 */
function testUpdateFormChoices() {
  console.log('=== フォーム選択肢更新テスト ===');
  updateFormDateChoices();
  console.log('=== テスト完了 ===');
}
